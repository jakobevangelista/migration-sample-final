# Migration Guide: Moving from Next-Auth to Clerk 

## Introduction

Migrating from Next-Auth to Clerk can be daunting, but this guide aims to help you achieve a seamless transition with zero downtime. This guide covers running both middlewares simultaneously, importing users while keeping your application active, and ensuring a smooth experience for your users.

## Prerequisites

Before you begin, ensure you have the following:

- An active Clerk account.
- Your current application using Next-Auth.
- Access to your user database.

## Migration Overview

To ensure a smooth migration with minimal disruption to your users, we will follow these steps:
1. [**Setup Trickle**](#1-setup-trickle)
   1. [**Add Clerk Middleware**](#add-clerk-middleware)
   2. [**Wrap Application in &lt;ClerkProvider>**](#wrap-application-in-clerkprovider)
   3. [**Wrap Application in &lt;ClerkMigrationTool>**](#wrapping-your-application-with-clerkmigrationtool)
   4. [**Create Helper Function and `/api/getUsersByIds`**](#create-the-helper-function-and-apigetuserbyid)
   5. [**Go to Migration Dashboard and set URL**](#go-to-migration-dashboard-and-set-getuserbyid-endpoint-url)
   6. [**Push to Prod**](#push-to-prod)
2. [**Batch Import**](#2-batch-import)
   1. [**Pass userIds to Migration Dashboard**](#passing-all-user-ids-to-migration-dashboard)
3. [**Replacing Sign In, Sign Up, and Data Access Patterns with Clerk**](#3-replacing-sign-in-sign-up-and-data-access-patterns-with-clerk)
4. [**Clean Up Migration Components**](#4-cleaning-up-migration-components)

## Migration Steps

During this part of the migration, users will sign in and sign up through nextauth.

### 1. Setup Trickle

Install the necessary packages: 
```bash
npm install @clerk/nextjs nextauth-clerk-migration-package
```
```bash
yarn add @clerk/nextjs nextauth-clerk-migration-package
```
```bash
pnpm add @clerk/nextjs nextauth-clerk-migration-package
```
```bash
bun add @clerk/nextjs nextauth-clerk-migration-package
```

#### Add Clerk Middleware

Add the Clerk middleware alongside the existing NextAuth middleware.

```js
// src/app/middleware.ts

import NextAuth from "next-auth";
import authConfig from "@/auth.config";
import { clerkMiddleware } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";

const { auth } = NextAuth(authConfig);
const nextAuthMiddle = auth(function middleware(req) {
  // custom middleware functions here
});

export default clerkMiddleware(async (clerkauth, req) => {
  await nextAuthMiddle(req); // works but needs AppRouteHandlerFnContext
  return NextResponse.next();
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

#### Wrap Application in &lt;ClerkProvider>

Wrap your application layout in the &lt;ClerkProvider> component to enable Clerk authentication. 

```js
// src/app/layout.tsx
import { ClerkProvider, SignedIn, UserButton } from "@clerk/nextjs";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body className={inter.className}>
          {children}
        </body>
      </html>
    </ClerkProvider>
  );
}
```

#### Wrapping your application with &lt;ClerkMigrationTool>

To seamlessly transition your users from NextAuth to Clerk without any downtime, you have to wrap the &lt;ClerkMigrationTool> around your application in a template.ts file in the root component and export the endpoint that the trickle wrapper calls along with some helper functions the endpoint needs. You can read more about what template.ts does [here](https://nextjs.org/docs/app/api-reference/file-conventions/template).

You need to pass a prop to the &lt;ClerkMigrationTool> component which is the url of the endpoint you will create in the next step which is called `/api/clerk-migrate`.

```js
// src/app/template.tsx

import { ClerkMigrationTool } from "nextauth-clerk-migration-package";

export default function Template({ children }: { children: React.ReactNode }) {
  return (
    <ClerkMigrationTool url={"/api/clerk-migrate"}>
      {children}
    </ClerkMigrationTool>
  );
}
```

#### Create &lt;ClerkMigrationTool> Endpoint

The &lt;ClerkMigrationTool> component calls this specific endpoint.

In `/api/clerk-migrate`, you have to make a fetch call to your migration API address with the signed in user's primary key ID and the clerk JWT.

In the example below, the `getuserIdFromSession` gets the needed ID. This example uses drizzle ORM with Neon Postgres DB to get the user's ID from the signed in session.

```js
// src/app/api/clerk-migrate/route.ts

import { auth } from "@/auth";
import { db } from "@/server/neonDb";
import { users } from "@/server/neonDb/schema";
import { eq } from "drizzle-orm";
import { NextRequest, NextResponse } from "next/server";

async function getUserIdFromSession() {
  const session = await auth();
  const user = await db.query.users.findFirst({
    where: eq(users.email, session!.user!.email!),
  });

  return user!.id;
}

export const POST = async (req: NextRequest) => {
  const userId = await getUserIdFromSession();
  const body = await req.json();
  const clerkJWT = body.clerkJWT;

  const res = await fetch("http://localhost:3001/api/addactiveuser", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${process.env.CLERK_SECRET_KEY}`,
    },
    body: JSON.stringify({ id: userId, clerkJWT }),
  });
  const data = await res.json();

  return new NextResponse(JSON.stringify({ data }), { status: res.status });
};
```



#### Create the helper function and /api/getUsersByIds

Next-auth allows you to bring your own db, that means we can't encompass all the possible adapters, but what we can do is have you implement helper functions that feed into our api. We require 1 external function you need to implement. 

The function is getUsersByIds which takes in an id and returns the Create User Backend API options. You can pass whatever options you'd like as an object through this function, we've also exported the type for you. You can find more information about the params [here](https://clerk.com/docs/references/backend/user/create-user)

These are an example of the helper function, you have to implement them yourself using your adapter. This example uses drizzle ORM with Neon Postgres.

```js
"use server";
import { auth } from "@/auth";
import { db } from "@/server/neonDb";
import { users } from "@/server/neonDb/schema";
import { eq } from "drizzle-orm";
import { type CreateUserParams } from "./routeHelper";

// used in the /api/getUsersByIds endpoint
export async function oldGetUsersByIds(ids: string[]) {
  const user = await db.select().from(users).where(inArray(users.id, ids));

  return users.map(user => ({
    external_id: user.id,
    email_address: [user.email],
    password: user.password,
    skip_password_checks: true,
    skip_password_requirement: true,
  })); // need to change this to openapi spec
}
```

Create another API endpoint called `/api/getUsersByIds` and use the helper function you implemented above in order to 

```js
import { NextRequest } from "next/server";
import { oldGetUsersByIds } from "@/sampleHelpers"


export const POST = async (req: NextRequest) => {
  const body = await req.json();

  const createParams = oldGetUsersByIds(body.ids);

  return new NextResponse(JSON.stringify(createParams), { status: res.status });
};
```

#### Go to migration dashboard and set getUserById endpoint url

Go to (insert link here) and set the getUserById endpoint.

#### Push to prod

You are now able to push to prod. Users will start to be created within clerk!

### 2. Batch Import

The batch import handles the migration of the rest of the users that the trickle doesn't migrate through a scheduled process, ensuring all users are migrated.

#### Passing all user IDs to Migration Dashboard

In the dashboard, there's a button to upload a .csv with a list of all of your user ids.

With the list of userIds uploaded, you can monitor the dashboard to see when all of your users are migrated. Once the number of active users waiting to be signed in goes to 0, you can switch to clerk!

### 3. Replacing Sign In, Sign Up, and Data Access Patterns with Clerk

New user sign ups go through the Clerk components.

```js
// src/app/sign-up/[[...sign-up]]/page.tsx
import { SignUp } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";

import { redirect } from "next/navigation";

export default function SignUpComponent() {
  const { userId }: { userId: string | null } = auth();
  if (userId === null) {
    return (
      <>
        <SignUp forceRedirectUrl={"/"} />
      </>
    );
  }

  return redirect("/");
}

// src/app/sign-in/[[...sign-in]]/page.tsx
import { SignIn } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";

import { redirect } from "next/navigation";

export default function SignInComponent() {
  const { userId }: { userId: string | null } = auth();
  if (userId === null) {
    return (
      <>
        <SignIn forceRedirectUrl={"/"} />
      </>
    );
  }

  return redirect("/");
}
```

#### Migrate Data Access Patterns and Helpers

Update all data access patterns to use Clerk's auth() instead of NextAuth's auth(). While the migration is happening, we will use the external_id (or use the patched auth helper) from Clerk in order to retrieve data.

```diff
- import { auth } from "@/auth";
+ import { auth } from "@clerk/nextjs/server"

-  const session = await auth();
-  if (!session) return <div>Not Signed In</div>;

+ const { userId } : { userId: string | null } = await auth();
+ if (!userId) <div>Not Signed In</div>;

or

+ import { currentUser } from "@clerk/nextjs/server"
+ const user = await currentUser();
+ if(!user) <div>Not Signed In </div>;

```

#### Custom session claims

Our sessions allow for conditional expressions. This would allow you add a session claim that will return either the `externalId` (the previous id for your user) when it exists, or the `userId` from Clerk. This will result in your imported users returning their `externalId` while newer users will return the Clerk `userId`.

In your Dashboard, go to Sessions -> Edit. Add the following: 

```json
{
	"userId": "{{user.external_id || user.id}}"
}
```

You can now access this value using the following:
```ts 
const { sessionClaims } = auth();
console.log(sessionClaims.userId) 
```

You can add the following for typescript: 
```js
// types/global.d.ts

export { };

declare global {
  interface CustomJwtSessionClaims {
    userId?: string;
  }
}
```

**Side note, we're currently patching the Clerk auth() function so that you can just set the userid as externalid instead of having to set external id, here's a patch to set the userid to externalId, once you can set userid on createUser, we can delete this and just reference userId**

We do this so that if you choose to store your user metadata in your own table, you can reference the information with just 1 key. You can export this from /src/app/_auth-migration/authPatch.ts.

```ts
/// src/app/_auth-migration/authPatch.ts 

import { auth as ogAuth } from "@clerk/nextjs/server";
// this function sets the userId to the sessionClaims userId which
// is the externalId but if exteranal id is not set, it will be
// the clerk user id
// this is used to only use one key for the user_metadata table in db calls
export function auth() {
  const ogAuthRes = ogAuth();
  ogAuthRes.userId = ogAuthRes.sessionClaims!.userId! as string;
  return ogAuthRes;
}

```

#### Here is an example of accessing the user metadata tenet tables with the new patterns (using the patched auth function)

```js
// src/app/page.tsx

import { auth as authPatch } from "./authPatch";
import { db } from "@/server/neonDb";
import { userAttributes } from "@/server/neonDb/schema";
import { eq } from "drizzle-orm";
import { redirect } from "next/navigation";

export default async function Home() {
  const clerkUser = authPatch();
  if (clerkUser === null) {
    return redirect("/sign-in");
  }

  const userAttribute = await db.query.userAttributes.findFirst({
    where: eq(userAttributes.id, clerkUser.userId!),
  });

  return (
    <>
      <div>Special Attribute: {userAttribute?.attribute}</div>
    </>
  );
}

```

#### We want users to edit their profile (attribute that are not classified as user metadata) in nextauth when they haven't been added to Clerk yet, but if they are in Clerk, we want them to edit profile information in Clerk, this allows them to change profile information during the migration process

```js
// src/app/changePassword/page.tsx

import { auth as nextAuthFunction } from "@/auth";
import { db } from "@/server/neonDb";
import {
  oldCheckHasSession,
} from "@/app/_auth-migration/sampleHelpers";
import { users } from "@/server/neonDb/schema";
import { auth } from "@clerk/nextjs/server";

import { UserButton } from "@clerk/nextjs";
import { redirect } from "next/navigation";

// checks if user is in Clerk, if in Clerk, change password in Clerk (semantic user button)
// if not in Clerk, change password in nextauth
export default async function Home() {
  const { userId }: { userId: string | null } = auth();
  const nexAuthUser = await oldCheckHasSession();

  if (userId === null && nexAuthUser === null) {
    return redirect("/sign-in");
  }

  // if the user hasn't been migrated to Clerk, change the password in nextauth
  if (userId === null) {
    return (
      <>
        <form
          action={async (formData) => {
            "use server";
            await db.update(users).set({
              password: formData.get("password") as string,
            });
          }}
        >
          <input type="password" name="password" />
          <button type="submit">Change Password</button>
        </form>
      </>
    );
  }

  // semantic representation of changing user profile in Clerk
  return (
    <>
      <UserButton />
    </>
  );
}
```

#### Here is an example of accessing the user metadata through Clerk's metadata

If you would like to store user metadata within Clerk's User object, here is how you do it.

```js
// wherever you call createUser

await clerkClient.users.createUser({
  firstName: "Test",
  lastName: "User",
  emailAddress: [ "testclerk123@gmail.com" ],
  password: "password",
  public_metadata: {role: "Engineer"},
  private_metadata: {skillIssue: "can't center div"},
  unsafe_metadata: {status: "happy"}
})
```

```js
// where you choose to access user object

import { currentUser } from '@clerk/nextjs/server';

export default async function Page() {
  const user = await currentUser();

  if (!user) return <div>Not signed in</div>;

  return <div>Role {user?.publicMetadata.role}</div>;
}
```

### 4. Cleaning up Migration Components

With all your users in clerk, and your clerk flows in prod, we can now delete all of the components used for migration.

You can delete the &lt;ClerkMigrationTool> component from template.ts. You can delete template.ts all together if you have no use for it.

You can delete the `/api/clerk-migrate` and `/api/getUsersByIds` routes.

After these are done, you have now successfully migrated to Clerk!