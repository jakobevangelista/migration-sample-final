# Migration Guide: Moving from Next-Auth to Clerk 

## Introduction

Migrating from Next-Auth to Clerk can be daunting, but this guide aims to help you achieve a seamless transition with zero downtime. This guide covers running both middlewares simultaneously, importing users while keeping your application active, and ensuring a smooth experience for your users.

## Prerequisites

Before you begin, ensure you have the following:

- An active Clerk account.
- Your current application using Next-Auth.
- Access to your user database.

## Migration Overview

To ensure a smooth migration with minimal disruption to your users, we will follow these steps:
1. [**Install @clerk/nextjs and nextauth-clerk-migration-package**](#1-install-clerknextjs-and-nextauth-clerk-migration-package)
2. [**Add Clerk Middleware**](#2-add-clerk-middleware)
3. [**Wrap Application in &ltClerkProvider>**](#3-wrap-application-in-clerkprovider)
4. [**Trickle Migration**](#4-trickle-migration)
5. [**Set getUserById URL in Dashboard**](#5-go-to-migration-dashboard-and-set-getuserbyid-endpoint-url)
6. [**Push to Prod**](#6-push-to-prod)
7. [**Batch Import**](#7-batch-import)
8. [**Sign-ups and Sign-ins through Clerk**](#8-sign-ups-and-sign-ins-go-through-the-clerk-components)

## Migration Steps

During this part of the migration, users will sign in and sign up through nextauth.

### 1. Install @clerk/nextjs and nextauth-clerk-migration-package

Install @clerk/nextjs and nextauth-clerk-migration-package, the second package contains all the components you'll need for the migration.

```bash
npm install @clerk/nextjs nextauth-clerk-migration-package
```
```bash
yarn add @clerk/nextjs nextauth-clerk-migration-package
```
```bash
pnpm add @clerk/nextjs nextauth-clerk-migration-package
```
```bash
bun add @clerk/nextjs nextauth-clerk-migration-package
```

### 2. Add Clerk Middleware

We need Clerk's middleware in order to use useSignIn within &lt;TrickleWrapper>.

First, add the Clerk middleware alongside the existing NextAuth middleware. Clerk middleware has to be the top wrapper for the entire middleware. In the example provided, we put a sample middleware functions within the next auth middleware, you can add whatever custom middleware functions you have.

```js
// src/app/middleware.ts

import NextAuth from "next-auth";
import authConfig from "@/auth.config";
import { clerkMiddleware } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";

const { auth } = NextAuth(authConfig);
const nextAuthMiddle = auth(function middleware(req) {
  // custom middleware functions here
});

export default clerkMiddleware(async (clerkauth, req) => {
  await nextAuthMiddle(req); // works but needs AppRouteHandlerFnContext
  return NextResponse.next();
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

### 3. Wrap Application in &lt;ClerkProvider>

Wrap your application layout in the &lt;ClerkProvider> component to enable Clerk authentication. 

(Highlight the lines of the wrapper)

```js
// src/app/layout.tsx
import { ClerkProvider, SignedIn, UserButton } from "@clerk/nextjs";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body className={inter.className}>
          {children}
        </body>
      </html>
    </ClerkProvider>
  );
}
```

### 4. Trickle Migration

To seamlessly transition your users from NextAuth to Clerk without any downtime, we give you a for your app that allows users to be created in clerk and later signed into clerk.

During this process, users will sign in and sign up through next-auth.

#### Create API Endpoint
In /app/api/clerk-migrate, copy and paste this code into route.ts. Make sure to use your own helper functions you previously implemented. You are need to implement the `getUserIdFromSession` function. This function returns the signed in user's primary key.

```js
// src/app/api/clerk-migrate/route.ts

import { auth } from "@/auth";
import { db } from "@/server/neonDb";
import { users } from "@/server/neonDb/schema";
import { eq } from "drizzle-orm";
import { NextRequest, NextResponse } from "next/server";

async function getUserIdFromSession() {
  const session = await auth();
  const user = await db.query.users.findFirst({
    where: eq(users.email, session!.user!.email!),
  });

  return user!.id;
}

export const POST = async (req: NextRequest) => {
  const token = await req.json();
  const userId = await getUserIdFromSession();

  const res = await fetch("http://localhost:3001/api/addactiveuser", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${process.env.CLERK_SECRET_KEY}`,
    },
    body: JSON.stringify({ id: userId }),
  });
  const data = await res.json();

  return new NextResponse(JSON.stringify({ data }), { status: res.status });
};
```

#### Wrapping your application with &lt;ClerkMigrationTool>

To seamlessly transition your users from NextAuth to Clerk without any downtime, you have to wrap the &lt;ClerkMigrationTool> around your application in a template.ts file in the root component and export the endpoint that the trickle wrapper calls along with some helper functions the endpoint needs. You can read more about what template.ts does [here](https://nextjs.org/docs/app/api-reference/file-conventions/template).

We have the wrapper made for you. You just need to import it, create a template.ts folder inside the root of your `app` directory, or `src` if you are using that, and wrap your app in it.

You need to pass a prop to the &lt;ClerkMigrationTool> component which is the url of the endpoint you created `/api/clerk-migrate`.

```js
// src/app/template.tsx

import { ClerkMigrationTool } from "nextauth-clerk-migration-package";

export default function Template({ children }: { children: React.ReactNode }) {
  return (
    <ClerkMigrationTool url={"/api/clerk-migrate"}>
      {children}
    </ClerkMigrationTool>
  );
}

```

#### Create the helper functions

Next-auth allows you to bring your own db, that means we can't encompass all the possible adapters, but what we can do is have you implement helper functions that feed into our api. We require 2 external functions you need to implement. 

The first is a getUserById which takes in an id and returns the createUser function's params, so you can pass whatever options you'd like as an object through this function, we've also exported the type for you. You can find more information about the params [here](https://clerk.com/docs/references/backend/user/create-user)

The second is a list of all your userId's.

These are an example of the helper function, you have to implement them yourself using your adapter. This example uses drizzle ORM with Neon Postgres.

```js
// src/app/_auth-migration/sampleHelpers.ts

"use server";
import { auth } from "@/auth";
import { db } from "@/server/neonDb";
import { users } from "@/server/neonDb/schema";
import { eq } from "drizzle-orm";
import { type CreateUserParams } from "./routeHelper";

// used on the second part of done for you batch
export async function oldGetUserById(id: string) {
  const user = await db.query.users.findFirst({
    where: eq(users.id, id),
  });

  return {
    external_id: user?.id,
    email_address: [user!.email],
    password: user!.password,
    skip_password_checks: true,
    skip_password_requirement: true,
  } as CreateUserParams; // need to change this to openapi spec
}

// returns the list of all your users
export async function getAllUsers() {
  const users = await db.query.users.findMany({
    columns: {
      id: true,
    },
  });

  return users;
}
```

#### Create /api/getUserById

Create another API endpoint called `/api/getUserById` and use the helper function you implemented above in order to 

```js
// src/app/api/clerk-migrate/route.ts
import { NextRequest } from "next/server";
import { oldGetUserById } from "@/sampleHelpers"


export const POST = async (req: NextRequest) => {
  const body = await req.json();

  const createParams = oldGetUserById(body.id);

  return new NextResponse(JSON.stringify(createParams), { status: res.status });
};
```

### 5. Go to migration dashboard and set getUserById endpoint url

Go to (insert link here) and set the getUserById endpoint.

### 6. Push to prod

You are now able to push to prod. Users will start to be created within clerk!

### 7. Batch Import

The batch import handles the migration of the rest of the users that the trickle doesn't migrate through a scheduled process, ensuring all users are migrated.

There are 2 major steps for batching, uploading a list of userId's to clerk, then importing them to Clerk. These process are done on our servers so we take the burden of compute, we just need a few things from you.

#### Passing all user IDs to Clerk's queue

In the dashboard, there's a button to upload a .csv with a list of all of your user ids.

With the list of userId's uploaded, you can monitor the dashboard to see when all of your users are migrated. Once the number of active users waiting to be signed in goes to 0, you can switch to clerk!

### 8. Sign-Ups and Sign-Ins go through the Clerk components

New user sign ups go through the Clerk components.

```js
// src/app/sign-up/[[...sign-up]]/page.tsx
import { SignUp } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";

import { redirect } from "next/navigation";

export default function SignUpComponent() {
  const { userId }: { userId: string | null } = auth();
  if (userId === null) {
    return (
      <>
        <SignUp forceRedirectUrl={"/"} />
      </>
    );
  }

  return redirect("/");
}

// src/app/sign-in/[[...sign-in]]/page.tsx
import { SignIn } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";

import { redirect } from "next/navigation";

export default function SignInComponent() {
  const { userId }: { userId: string | null } = auth();
  if (userId === null) {
    return (
      <>
        <SignIn forceRedirectUrl={"/"} />
      </>
    );
  }

  return redirect("/");
}
```

## Migrate Data Access Patterns and Helpers

Update all data access patterns to use Clerk's auth() instead of NextAuth's auth(). While the migration is happening, we will use the external_id (or use the patched auth helper) from Clerk in order to retrieve data.

```diff
- import { auth } from "@/auth";
+ import { auth } from "@clerk/nextjs/server"

-  const session = await auth();
-  if (!session) return <div>Not Signed In</div>;

+ const { userId } : { userId: string | null } = await auth();
+ if (!userId) <div>Not Signed In</div>;

or

+ import { currentUser } from "@clerk/nextjs/server"
+ const user = await currentUser();
+ if(!user) <div>Not Signed In </div>;

```

#### Custom session claims

Our sessions allow for conditional expressions. This would allow you add a session claim that will return either the `externalId` (the previous id for your user) when it exists, or the `userId` from Clerk. This will result in your imported users returning their `externalId` while newer users will return the Clerk `userId`.

In your Dashboard, go to Sessions -> Edit. Add the following: 

```json
{
	"userId": "{{user.external_id || user.id}}"
}
```

You can now access this value using the following:
```ts 
const { sessionClaims } = auth();
console.log(sessionClaims.userId) 
```

You can add the following for typescript: 
```js
// types/global.d.ts

export { };

declare global {
  interface CustomJwtSessionClaims {
    userId?: string;
  }
}
```

**Side note, we're currently patching the Clerk auth() function so that you can just set the userid as externalid instead of having to set external id, here's a patch to set the userid to externalId, once you can set userid on createUser, we can delete this and just reference userId**

We do this so that if you choose to store your user metadata in your own table, you can reference the information with just 1 key. You can export this from /src/app/_auth-migration/authPatch.ts.

```ts
/// src/app/_auth-migration/authPatch.ts 

import { auth as ogAuth } from "@clerk/nextjs/server";
// this function sets the userId to the sessionClaims userId which
// is the externalId but if exteranal id is not set, it will be
// the clerk user id
// this is used to only use one key for the user_metadata table in db calls
export function auth() {
  const ogAuthRes = ogAuth();
  ogAuthRes.userId = ogAuthRes.sessionClaims!.userId! as string;
  return ogAuthRes;
}

```

#### Here is an example of accessing the user metadata tenet tables with the new patterns (using the patched auth function)

```js
// src/app/page.tsx

import { auth as authPatch } from "./authPatch";
import { db } from "@/server/neonDb";
import { userAttributes } from "@/server/neonDb/schema";
import { eq } from "drizzle-orm";
import { redirect } from "next/navigation";

export default async function Home() {
  const clerkUser = authPatch();
  if (clerkUser === null) {
    return redirect("/sign-in");
  }

  const userAttribute = await db.query.userAttributes.findFirst({
    where: eq(userAttributes.id, clerkUser.userId!),
  });

  return (
    <>
      <div>Special Attribute: {userAttribute?.attribute}</div>
    </>
  );
}

```

#### We want users to edit their profile (attribute that are not classified as user metadata) in nextauth when they haven't been added to Clerk yet, but if they are in Clerk, we want them to edit profile information in Clerk, this allows them to change profile information during the migration process

```js
// src/app/changePassword/page.tsx

import { auth as nextAuthFunction } from "@/auth";
import { db } from "@/server/neonDb";
import {
  oldCheckHasSession,
} from "@/app/_auth-migration/sampleHelpers";
import { users } from "@/server/neonDb/schema";
import { auth } from "@clerk/nextjs/server";

import { UserButton } from "@clerk/nextjs";
import { redirect } from "next/navigation";

// checks if user is in Clerk, if in Clerk, change password in Clerk (semantic user button)
// if not in Clerk, change password in nextauth
export default async function Home() {
  const { userId }: { userId: string | null } = auth();
  const nexAuthUser = await oldCheckHasSession();

  if (userId === null && nexAuthUser === null) {
    return redirect("/sign-in");
  }

  // if the user hasn't been migrated to Clerk, change the password in nextauth
  if (userId === null) {
    return (
      <>
        <form
          action={async (formData) => {
            "use server";
            await db.update(users).set({
              password: formData.get("password") as string,
            });
          }}
        >
          <input type="password" name="password" />
          <button type="submit">Change Password</button>
        </form>
      </>
    );
  }

  // semantic representation of changing user profile in Clerk
  return (
    <>
      <UserButton />
    </>
  );
}
```

#### Here is an example of accessing the user metadata through Clerk's metadata

If you would like to store user metadata within Clerk's User object, here is how you do it.

```js
// wherever you call createUser

await clerkClient.users.createUser({
  firstName: "Test",
  lastName: "User",
  emailAddress: [ "testclerk123@gmail.com" ],
  password: "password",
  public_metadata: {role: "Engineer"},
  private_metadata: {skillIssue: "can't center div"},
  unsafe_metadata: {status: "happy"}
})
```

```js
// where you choose to access user object

import { currentUser } from '@clerk/nextjs/server';

export default async function Page() {
  const user = await currentUser();

  if (!user) return <div>Not signed in</div>;

  return <div>Role {user?.publicMetadata.role}</div>;
}
```